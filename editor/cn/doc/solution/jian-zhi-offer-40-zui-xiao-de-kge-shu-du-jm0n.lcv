暴力法：今天的面试就到这里，回去等消息吧！

* []

```javascript
/**
 * 暴力法：
 * Accepted
 * 39/39 cases passed (100 ms)
 * Your runtime beats 50.06 % of javascript submissions
 * Your memory usage beats 50.66 % of javascript submissions (45.2 MB)
 * 耗时 0:0:14
 */
var getLeastNumbers = function (arr, k) {
  return arr.sort((a, b) => a - b).slice(0, k);
};
```

快排，不需要数组完全有序，只需要找到index===k-1使得数组左半部分小于index下标对应的元素值即可。

* []

```javascript
/**
 * 快排
 * Accepted
 * 39/39 cases passed (76 ms)
 * Your runtime beats 96.32 % of javascript submissions
 * Your memory usage beats 43.06 % of javascript submissions (45.3 MB)
 */
var getLeastNumbers = function (arr, k) {
  const partition = function (left, right) {
    const guard = arr[left];
    let index = left;
    for (let i = left + 1; i <= right; i++) {
      if (arr[i] < guard) {
        index++;
        [arr[i], arr[index]] = [arr[index], arr[i]];
      }
    }
    [arr[left], arr[index]] = [arr[index], arr[left]];
    return index;
  };
  let left = 0,
    right = arr.length - 1;
  while (left < right) {
    const mid = partition(left, right);
    if (mid === k - 1) {
      break;
    } else if (mid > k - 1) {
      right = mid - 1;
    } else {
      left = mid + 1;
    }
  }
  return arr.slice(0, k);
};
```

js堆排序实现优先队列

* []

```javascript
// 堆排序实现优先队列
class myPriorityQueue {
  constructor(compare) {
    this.heap = []; // 用数组存储堆
    this.compare = compare || ((a, b) => a > b); // 比较函数，默认为大顶堆
  }
  // 插入元素
  insert(value) {
    this.heap.push(value);
    this.bubbleUp();
  }
  // 取出并移除根节点
  extract() {
    if (this.heap.length === 0) return null;
    let root = this.heap[0];
    this.heap[0] = this.heap.pop();
    this.sinkDown();
    return root;
  }
  // 上浮操作
  bubbleUp() {
    let index = this.heap.length - 1;
    let parentIndex = Math.floor((index - 1) / 2);
    // 当插入的节点大于其父节点时，交换位置，并更新索引，继续上浮
    while (
      index > 0 &&
      this.compare(this.heap[index], this.heap[parentIndex])
    ) {
      [this.heap[index], this.heap[parentIndex]] = [
        this.heap[parentIndex],
        this.heap[index],
      ];
      index = parentIndex;
      parentIndex = Math.floor((index - 1) / 2);
    }
  }
  // 下沉操作
  sinkDown() {
    let index = 0;
    let leftIndex = index * 2 + 1;
    let rightIndex = index * 2 + 2;
    // 找出三者中最大(小)的一个，如果根节点不是最大（小）的，就交换位置，并更新索引，继续下沉
    while (leftIndex < this.heap.length) {
      let maxIndex = rightIndex;
      if (
        rightIndex >= this.heap.length ||
        this.compare(this.heap[leftIndex], this.heap[rightIndex])
      ) {
        maxIndex = leftIndex;
      }
      if (this.compare(this.heap[maxIndex], this.heap[index])) {
        [this.heap[index], this.heap[maxIndex]] = [
          this.heap[maxIndex],
          this.heap[index],
        ];
        index = maxIndex;
        leftIndex = index * 2 + 1;
        rightIndex = index * 2 + 2;
      } else {
        break;
      }
    }
  }
}
```

小顶堆，所有元素入堆之后弹出前k个

* []

```javascript
/**
 * 小顶堆，所有元素入堆之后弹出前k个
 * Accepted
 * 39/39 cases passed (108 ms)
 * Your runtime beats 31.08 % of javascript submissions
 * Your memory usage beats 7.6 % of javascript submissions (49.5 MB)
 */
var getLeastNumbers = function (arr, k) {
  let pq = new myPriorityQueue((a, b) => a < b);
  for (let item of arr) {
    pq.insert(item);
  }
  const res = [];
  for (let i = 0; i < k; i++) {
    res.push(pq.extract());
  }
  return res;
};
```

计数排序

* []

```javascript
/**
 * 计数排序
 * Accepted
 * 39/39 cases passed (112 ms)
 * Your runtime beats 25.62 % of javascript submissions
 * Your memory usage beats 8.19 % of javascript submissions (49.4 MB)
 */
function getLeastNumbers(arr, k) {
  if (k == 0 || arr.length == 0) {
    return [];
  }
  let counter = new Array(10001).fill(0);
  for (let num of arr) {
    counter[num]++;
  }
  let res = [];
  let idx = 0;
  for (let num = 0; num < counter.length; num++) {
    while (counter[num]-- > 0 && idx < k) {
      res[idx++] = num;
    }
    if (idx == k) {
      break;
    }
  }
  return res;
}
```

